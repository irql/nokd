
#include "kd.h"

KD_UART_STATUS
KdUart16550SendByte(
    _In_ PKD_PORT Port,
    _In_ UCHAR    Byte
);

KD_UART_STATUS
KdUart16550RecvByte(
    _In_ PKD_PORT Port,
    _In_ PUCHAR   Byte
);

//https://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming

#define COM_THR       0
#define COM_RBR       0
#define COM_DLL       0

#define COM_IER       1
#define COM_DLH       1

#define COM_FCR       2
#define COM_IIR       2
#define COM_LCR       3
#define COM_MCR       4
#define COM_LSR       5
#define COM_MSR       6
#define COM_SCR       7

#define COM_LS_DR                   ( 1 << 0 )
#define COM_LS_OE                   ( 1 << 0 )
#define COM_LS_PE                   ( 1 << 2 )
#define COM_LS_FE                   ( 1 << 3 )
#define COM_LS_BI                   ( 1 << 4 )
#define COM_LS_THRE                 ( 1 << 5 )
#define COM_LS_TEMT                 ( 1 << 6 )
#define COM_LS_ER_INP               ( 1 << 7 )

PWSTR
KdpIdentifyUart(
    _In_ PKD_PORT Port
)
{
    __outbyte( Port->Uart.Base + COM_FCR, 0xE7 );

    return NULL;
}

KD_UART_STATUS
KdUart16550InitializePort(
    _In_ PKD_PORT Port,
    _In_ ULONG64  Index
)
{
    Port->Uart.Index = Index;

    switch ( Port->Uart.Index ) {
    case 1:
        Port->Uart.Base = 0x3F8;
        break;
    case 2:
        Port->Uart.Base = 0x2F8;
    case 3:
        Port->Uart.Base = 0x3E8;
        break;
    case 4:
        Port->Uart.Base = 0x2E8;
        break;
    default:
        NT_ASSERT( FALSE );
    }

    //
    // No interrupts should be generated by the chip,
    // data will be polled.
    //

    __outbyte( Port->Uart.Base + COM_IER, 0 );

    //
    // Set the DLAB to access to DL bytes.
    //

    __outbyte( Port->Uart.Base + COM_LCR, 0x80 );

    //
    // Set the divisor latch to 1. 
    // 115200/1 = 115200.
    //

    __outbyte( Port->Uart.Base + COM_DLL, 0x01 );
    __outbyte( Port->Uart.Base + COM_DLH, 0x00 );

    //
    // Clear the DLAB, set 8 bits, no parity and one stop bit.
    //

    __outbyte( Port->Uart.Base + COM_LCR, 0x03 );

    //
    // Enable FIFOs and clear receive/transmit FIFO.
    //

    __outbyte( Port->Uart.Base + COM_FCR, 0xC7 );//0x03 );

    //
    // Request to send, data terminal ready (RTS/DTR).
    //

    __outbyte( Port->Uart.Base + COM_MCR, 0x0B );

    //
    // Put the chip in loopback mode and send 0b10101110,
    // then query the RBR and check data was received 
    // successfully, this just checks if the chop is faulty
    // or not.
    //

    __outbyte( Port->Uart.Base + COM_MCR, 0x1E );
    __outbyte( Port->Uart.Base + COM_THR, 0xAE );

    //if ( __inbyte( Port->Uart.Base + COM_RBR ) != 0xAE ) {

    UCHAR FaultByte;

    if ( KdUart16550RecvByte( Port, &FaultByte ) != KdUartSuccess ||
         FaultByte != 0xAE ) {
        KdUart16550RecvByte( Port, &FaultByte );
        KdUart16550RecvByte( Port, &FaultByte );
        DbgPrint( "FaultByte: %lx\n", FaultByte );

        return STATUS_UNSUCCESSFUL;
    }

    __outbyte( Port->Uart.Base + COM_MCR, 0x0F );

    Port->Recv = KdUart16550RecvByte;
    Port->Send = KdUart16550SendByte;

    return KdUartSuccess;
}

BOOLEAN
KdUart16550SendReady(
    _In_ PKD_PORT Port
)
{
    return ( __inbyte( Port->Uart.Base + COM_LSR ) & COM_LS_THRE ) == COM_LS_THRE;
}

BOOLEAN
KdUart16550RecvReady(
    _In_ PKD_PORT Port
)
{
    return ( __inbyte( Port->Uart.Base + COM_LSR ) & COM_LS_DR ) == COM_LS_DR;
}

KD_UART_STATUS
KdUart16550SendByte(
    _In_ PKD_PORT Port,
    _In_ UCHAR    Byte
)
{
    ULONG64 TimeOut = 4000;

    while ( !KdUart16550SendReady( Port ) && TimeOut != 0 ) {

        TimeOut--;
    }

    if ( TimeOut > 0 ) {
        __outbyte( Port->Uart.Base + COM_THR, Byte );

        return KdUartSuccess;
    }
    else {

        return KdUartError;
    }
}

KD_UART_STATUS
KdUart16550RecvByte(
    _In_ PKD_PORT Port,
    _In_ PUCHAR   Byte
)
{
    ULONG64 TimeOut = 4000;

    DbgPrint( "begin recv! %lx\n", Port->Uart.Base );

    while ( !KdUart16550RecvReady( Port ) && TimeOut != 0 ) {

        TimeOut--;
    }

    if ( TimeOut > 0 ) {
        *Byte = __inbyte( Port->Uart.Base + COM_RBR );

        return KdUartSuccess;
    }
    else {
        DbgPrint( "time out!\n" );

        return KdUartNoData;
    }
}
